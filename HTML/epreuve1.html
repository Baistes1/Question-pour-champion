<!doctype html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Questions pour un Champion</title>

  <style>
    :root{
      --bg:#06060b;
      --panel:#0b1b4a;
      --panel2:#071335;
      --blue:#0b4fe3;
      --blue2:#0839a8;
      --gold:#f8d54b;
      --gold2:#f2a900;
      --text:#ffffff;
      --muted:rgba(255,255,255,.75);
      --shadow: 0 12px 35px rgba(0,0,0,.45);
      --radius:18px;
    }

    *{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    body{
      background: radial-gradient(1200px 700px at 50% 0%, rgba(0, 115, 255, 0.862), transparent 60%), var(--blue);
      color:var(--text);
      height:100vh;
      overflow:hidden;
    }

    /* Stars */
    .stars{position:fixed;inset:0;z-index:-1;pointer-events:none;overflow:hidden;}
    .star{
      position:absolute;
      border-radius:50%;
      background:white;
      box-shadow:0 0 4px rgba(255,255,255,.8),0 0 8px rgba(255,255,255,.6),0 0 16px rgba(255,255,255,.4);
      animation: starTwinkle linear infinite;
    }
    .star.small{width:1px;height:1px;opacity:.5;}
    .star.medium{width:2px;height:2px;opacity:.7;}
    .star.large{
      width:3px;height:3px;opacity:1;
      box-shadow:0 0 6px rgba(255,255,255,1),0 0 14px rgba(255,255,255,.9),0 0 26px rgba(255,255,255,.6);
    }
    @keyframes starTwinkle{
      0%,100%{opacity:.4;transform:scale(1);}
      50%{opacity:1;transform:scale(1.3);}
    }

    /* Layout */
    .app{height:100vh;display:grid;grid-template-rows:1fr 3px 0.7fr;}

    .top{
      background: linear-gradient(180deg, rgba(0, 102, 245, 0.35), rgba(7,19,53,.15));
      padding:18px;
      display:grid;
      grid-template-columns:240px minmax(0,1fr) 240px;
      gap:18px;
      align-items:center;
      justify-items:center;
    }

    .divider{
      background: linear-gradient(90deg, transparent, var(--gold), transparent);
      box-shadow:0 0 12px rgba(248,213,75,.55);
    }

    .bottom{
      background: linear-gradient(180deg, rgba(11,27,74,.35), rgba(7,19,53,.65));
      padding:18px;
      display:grid;
      grid-template-columns:1fr;
      align-items:center;
      justify-items:center;
      position:relative;
    }

    /* Players */
    .players{
      height:100%;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:14px;
      width:100%;
      max-width:240px;
    }

    .player{
      display:grid;
      grid-template-columns:64px 1fr;
      gap:12px;
      align-items:center;
      padding:12px;
      border-radius:16px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.08);
      box-shadow:0 10px 20px rgba(0,0,0,.25);
    }

    .avatar{
      width:75px;height:75px;border-radius:50%;
      overflow:hidden;
      display:grid;place-items:center;
      background: radial-gradient(circle at 30% 30%, rgba(248,213,75,.25), rgba(11,79,227,.25));
      border:2px solid rgba(248,213,75,.55);
      box-shadow:0 0 0 3px rgba(242,169,0,.18), 0 0 18px rgba(248,213,75,.22);
      position:relative;
    }
    .avatar img{width:100%;height:100%;object-fit:cover;display:block}
    .avatar .fallback{
      position:absolute;inset:0;
      display:none;place-items:center;
      font-weight:800;font-size:18px;
      color:white;
      background:rgba(0,0,0,.3);
    }

    .player.active{
      border-color: rgba(255,255,255,.25);
      box-shadow: 0 0 0 1px rgba(248,213,75,.35), 0 16px 28px rgba(0,0,0,.35);
    }

    .meta{display:flex;flex-direction:column;gap:6px}
    .name{font-weight:700;letter-spacing:.2px}
    .pts{
      width:max-content;
      padding:6px 10px;border-radius:999px;
      background: linear-gradient(180deg, var(--gold), var(--gold2));
      color:#0a1e52;
      font-weight:800;
      font-size:13px;
      box-shadow:0 8px 18px rgba(242,169,0,.18);
    }

    /* Question card */
    .question{
      width:min(860px, 100%);
      padding:22px;
      border-radius:var(--radius);
      background: rgba(0,0,0,.22);
      border:1px solid rgba(248,213,75,.22);
      box-shadow:var(--shadow);
      position:relative;
      overflow:hidden;
      justify-self:center;
      align-self:center;
      margin:0 auto;
    }
    .question::before{
      content:"";
      position:absolute;inset:-2px;
      background: radial-gradient(800px 220px at 50% 0%, rgba(248,213,75,.18), transparent 60%);
      pointer-events:none;
    }
    .question h1{
      font-size: clamp(16px, 2.5vw, 28px);
      line-height: 1.2;
      text-align:center;
      text-shadow: 0 8px 18px rgba(0,0,0,0.4);
      position:relative;
      padding:6px 10px;
    }
    .hint{
      margin-top:10px;
      text-align:center;
      color:var(--muted);
      font-size:13px;
      position:relative;
    }

    /* Buzzer */
    .buzzerWrap{
      position:absolute;
      top:-54px;
      left:50%;
      transform:translateX(-50%);
      z-index:5;
    }
    .buzzer{
      width:120px;height:120px;border-radius:50%;
      display:grid;place-items:center;
      cursor:pointer;
      user-select:none;
      font-weight:900;
      font-size:34px;
      color:white;
      background: radial-gradient(circle at 30% 30%, #ff4b4b, #b80000);
      border:8px solid rgba(255,255,255,.06);
      box-shadow:
        0 0 0 6px rgba(248,213,75,.14),
        0 0 40px rgba(255,0,0,.85),
        0 0 95px rgba(255,0,0,.45),
        inset 0 -10px 22px rgba(0,0,0,.4),
        inset 0 10px 22px rgba(255,255,255,.20);
      animation: pulse 0.65s infinite ease-in-out;
      position:relative;
    }
    .buzzer::after{
      content:"";
      position:absolute;inset:0;border-radius:50%;
      background: radial-gradient(circle at 35% 35%, rgba(255,255,255,.45), transparent 55%);
      pointer-events:none;
      opacity:.7;
    }
    .buzzer:active{transform: scale(.94); filter: brightness(1.25);}

    @keyframes pulse{
      0%,100%{
        transform:scale(1);
        box-shadow:
          0 0 0 6px rgba(248,213,75,.14),
          0 0 35px rgba(255,0,0,.85),
          0 0 85px rgba(255,0,0,.40),
          inset 0 -10px 22px rgba(0,0,0,.4),
          inset 0 10px 22px rgba(255,255,255,.20);
      }
      50%{
        transform:scale(1.12);
        box-shadow:
          0 0 0 10px rgba(248,213,75,.18),
          0 0 55px rgba(255,0,0,1),
          0 0 130px rgba(255,70,70,.55),
          inset 0 -12px 26px rgba(0,0,0,.5),
          inset 0 12px 26px rgba(255,255,255,.26);
      }
    }

    .buzzer.flash{animation: flash .18s linear}
    @keyframes flash{0%{filter:brightness(1)}50%{filter:brightness(1.9)}100%{filter:brightness(1)}}

    .buzzer.buzzed{
      animation:none;
      background: radial-gradient(circle at 30% 30%, #49e06d, #167a2c);
      box-shadow:
        0 0 0 6px rgba(248,213,75,.14),
        0 0 40px rgba(73,224,109,.65),
        0 0 95px rgba(73,224,109,.35),
        inset 0 -10px 22px rgba(0,0,0,.4),
        inset 0 10px 22px rgba(255,255,255,.20);
    }

    .buzzer.timeup{
      animation:none;
      cursor:default;
      background: radial-gradient(circle at 30% 30%, #6a6a6a, #2d2d2d);
      box-shadow:
        0 0 0 6px rgba(248,213,75,.10),
        0 0 18px rgba(255,255,255,.10),
        0 0 50px rgba(0,0,0,.55),
        inset 0 -10px 22px rgba(0,0,0,.4),
        inset 0 10px 22px rgba(255,255,255,.12);
    }

    /* Answers */
    .answers{
      width:min(2000px, 100%);
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px 115px;
      padding:18px;
      border-radius:var(--radius);
      background: rgba(0,0,0,.20);
      border:4px solid rgba(239, 224, 8, 0.168);
      box-shadow:var(--shadow);
    }

    .answer{
      padding:18px 30px;
      border-radius:140px;
      background: linear-gradient(180deg, rgba(248,213,75,.98), rgba(242,169,0,.98));
      color:#0a1e52;
      font-weight:900;
      font-size: clamp(14px, 2.2vw, 20px);
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      cursor:pointer;
      user-select:none;
      border:2px solid rgba(0,0,0,.08);
      box-shadow:0 10px 20px rgba(0,0,0,.28);
      transition: transform .12s ease, filter .12s ease, opacity .12s ease;
      min-height:72px;
    }

    .answer:hover{transform: translateY(-2px); filter: brightness(1.02)}
    .answer:active{transform: translateY(0); filter: brightness(.98)}
    .answer.correct{background: linear-gradient(180deg, #3cff6a, #17a63a); color:white;}
    .answer.wrong{background: linear-gradient(180deg, #ff3d3d, #b50000); color:white;}
    .answer.disabled{pointer-events:none;opacity:.55}

    @media (max-width: 900px){
      .top{grid-template-columns: 1fr; grid-template-rows:auto auto auto}
      .players{flex-direction:row; justify-content:space-between}
      .player{grid-template-columns: 54px 1fr}
      .avatar{width:54px;height:54px}
      .answers{grid-template-columns:1fr}
      .buzzerWrap{top:-58px}
    }
  </style>
</head>

<body>
  <div class="stars" id="stars"></div>

  <main class="app">
    <section class="top">
      <div class="players" id="leftPlayers">
        <div class="player active" data-player="1">
          <div class="avatar">
            <!-- remplac√© par JS depuis localStorage -->
            <img id="avatar-1" class="avatar-img" alt="Joueur 1" />
            <div class="fallback">1</div>
          </div>
          <div class="meta">
            <div class="name" id="name-1">Joueur 1</div>
            <div class="pts" id="pts-1">0 pts</div>
          </div>
        </div>

        <div class="player" data-player="2">
          <div class="avatar">
            <img id="avatar-2" class="avatar-img" alt="Bot 1" />
            <div class="fallback">2</div>
          </div>
          <div class="meta">
            <div class="name" id="name-2">Bot 1</div>
            <div class="pts" id="pts-2">0 pts</div>
          </div>
        </div>
      </div>

      <div class="question">
        <h1 id="questionText">Chargement‚Ä¶</h1>
        <div class="hint">Clique sur le buzzer pour r√©pondre.</div>
      </div>

      <div class="players" id="rightPlayers">
        <div class="player" data-player="3">
          <div class="avatar">
            <img id="avatar-3" class="avatar-img" alt="Bot 2" />
            <div class="fallback">3</div>
          </div>
          <div class="meta">
            <div class="name" id="name-3">Bot 2</div>
            <div class="pts" id="pts-3">0 pts</div>
          </div>
        </div>

        <div class="player" data-player="4">
          <div class="avatar">
            <img id="avatar-4" class="avatar-img" alt="Bot 3" />
            <div class="fallback">4</div>
          </div>
          <div class="meta">
            <div class="name" id="name-4">Bot 3</div>
            <div class="pts" id="pts-4">0 pts</div>
          </div>
        </div>
      </div>
    </section>

    <div class="divider"></div>

    <section class="bottom">
      <div class="buzzerWrap">
        <div class="buzzer" id="buzzer">‚Ä¶</div>
      </div>

      <div class="answers" id="answers">
        <div class="answer">A</div>
        <div class="answer">B</div>
        <div class="answer">C</div>
        <div class="answer">D</div>
      </div>
    </section>
  </main>

  <script>
    /* =========================
       √âPREUVE 1
       - Questions JSON GitHub raw
       - J1 = joueur s√©lectionn√© (nom + avatar via localStorage "qpc_player")
       - Bots nomm√©s + avatars fixes
       - Chrono GLOBAL d‚Äô√©preuve (ne se reset pas) + fen√™tre r√©ponse apr√®s buzz
       ========================= */

    (function () {
      // ---------- CONFIG ----------
      const POINTS_VICTOIRE = 9;

      // Temps "buzz ouvert" / question (affich√© sur le buzzer) : tu peux le garder
      const TEMPS_LIMITE = 20;

      // Fen√™tre de r√©ponse apr√®s buzz HUMAIN
      const TEMPS_REPONSE_APRES_BUZZ = 5;

      // Chrono GLOBAL d‚Äô√©preuve (NE SE RESET PAS)
      const EPREUVE_DURATION = 180;
      const NEXT_PAGE_URL = "./epreuve2.html";

      const QUESTIONS_URL =
        "https://raw.githubusercontent.com/Baistes1/Question-pour-champion/main/JSON/epreuve1.json";

      const HUMAN = 1;
      const BOTS = [2, 3, 4];

      const BOT_CONFIG = {
        2: { buzzChance: 0.60, buzzDelayMin: 600,  buzzDelayMax: 3500, accuracy: 0.60 },
        3: { buzzChance: 0.50, buzzDelayMin: 700,  buzzDelayMax: 4500, accuracy: 0.50 },
        4: { buzzChance: 0.40, buzzDelayMin: 900,  buzzDelayMax: 6000, accuracy: 0.40 },
      };

      // Bots : noms + avatars (mets tes vrais chemins ici)
      const BOT_PROFILE = {
        2: { name: "Atlas",  avatar: "Images/bot_orange.png" },
        3: { name: "Nova",   avatar: "Images/bot_rose.png" },
        4: { name: "Orion",  avatar: "Images/bot_turquoise.png" },
      };

      // ---------- DOM ----------
      const $ = (sel) => document.querySelector(sel);
      const $$ = (sel) => Array.from(document.querySelectorAll(sel));

      const dom = {
        starsWrap: $("#stars"),
        questionText: $("#questionText"),
        hint: $(".hint"),
        buzzer: $("#buzzer"),
        answers: $$("#answers .answer"),
        pts: { 1: $("#pts-1"), 2: $("#pts-2"), 3: $("#pts-3"), 4: $("#pts-4") },
        playerCards: $$(".player"),

        name: { 1: $("#name-1"), 2: $("#name-2"), 3: $("#name-3"), 4: $("#name-4") },
        avatar: { 1: $("#avatar-1"), 2: $("#avatar-2"), 3: $("#avatar-3"), 4: $("#avatar-4") },
      };

      if (!dom.questionText || !dom.buzzer || dom.answers.length !== 4) {
        throw new Error("DOM incomplet: v√©rifie #questionText, #buzzer, et 4 √©l√©ments .answer dans #answers.");
      }

      // ---------- STARS ----------
      function buildStars() {
        if (!dom.starsWrap) return;
        dom.starsWrap.innerHTML = "";
        const count = 140;

        for (let i = 0; i < count; i++) {
          const s = document.createElement("div");
          const r = Math.random();
          s.className = "star " + (r < 0.75 ? "small" : r < 0.95 ? "medium" : "large");
          s.style.left = `${Math.random() * 100}%`;
          s.style.top = `${Math.random() * 100}%`;
          s.style.animationDuration = `${2 + Math.random() * 4}s`;
          s.style.animationDelay = `${Math.random() * 3}s`;
          dom.starsWrap.appendChild(s);
        }
      }

      // ---------- PROFILS ----------
      function safeParseJSON(raw) {
        try { return JSON.parse(raw); } catch { return null; }
      }

      function getHumanPlayer() {
        const raw = localStorage.getItem("qpc_player");
        const parsed = raw ? safeParseJSON(raw) : null;
        if (!parsed) return { name: "Joueur 1", avatar: "" };
        return { name: parsed.name || "Joueur 1", avatar: parsed.avatar || "" };
      }

      function applyProfiles() {
        // J1 = joueur s√©lectionn√©
        const human = getHumanPlayer();
        if (dom.name[1]) dom.name[1].textContent = human.name;
        if (dom.avatar[1]) dom.avatar[1].src = human.avatar || "";

        // Bots
        for (const p of BOTS) {
          const profile = BOT_PROFILE[p] || { name: `Bot ${p}`, avatar: "" };
          if (dom.name[p]) dom.name[p].textContent = profile.name;
          if (dom.avatar[p] && profile.avatar) dom.avatar[p].src = profile.avatar;
        }

        // fallback images cass√©es
        $$(".avatar-img").forEach((img) => {
          img.addEventListener("error", () => {
            const wrap = img.closest(".avatar");
            if (!wrap) return;
            img.style.display = "none";
            const fb = wrap.querySelector(".fallback");
            if (fb) fb.style.display = "grid";
          });
        });
      }

      // ---------- STATE ----------
      const state = {
        scores: { 1: 0, 2: 0, 3: 0, 4: 0 },

        questions: [],
        questionIndex: 0,
        questionNumber: 1,

        gagnant_trouve: false,

        // buzz fen√™tre "question"
        buzzOpen: false,
        respondingPlayer: null,
        awaitingHumanAnswer: false,

        correctIndex: null,

        // timer question (buzz ouvert) => affich√© sur buzzer
        remaining: TEMPS_LIMITE,
        timerId: null,

        // fen√™tre r√©ponse apr√®s buzz humain
        answerWindowRemaining: TEMPS_REPONSE_APRES_BUZZ,
        answerWindowId: null,

        // bot timers
        botTimeouts: [],

        // chrono global d‚Äô√©preuve (NE SE RESET PAS)
        epreuveRemaining: EPREUVE_DURATION,
        epreuveTimerId: null,
      };

      // ---------- UI HELPERS ----------
      function setHint(msg) {
        if (dom.hint) dom.hint.textContent = msg;
      }

      function setBuzzerText(sec) {
        dom.buzzer.textContent = `${sec}s`;
      }

      function setBuzzerState(mode) {
        dom.buzzer.classList.remove("buzzed", "timeup", "flash");
        if (mode === "buzzed") dom.buzzer.classList.add("buzzed");
        if (mode === "timeup") dom.buzzer.classList.add("timeup");
      }

      function flashBuzzer() {
        dom.buzzer.classList.add("flash");
        setTimeout(() => dom.buzzer.classList.remove("flash"), 180);
      }

      function renderScores() {
        for (let p = 1; p <= 4; p++) {
          if (dom.pts[p]) dom.pts[p].textContent = `${state.scores[p]} pts`;
        }
      }

      function setActivePlayer(p) {
        dom.playerCards.forEach((card) => {
          const id = Number(card.dataset.player);
          card.classList.toggle("active", id === p);
        });
      }

      function resetAnswersUI() {
        dom.answers.forEach((a) => a.classList.remove("correct", "wrong", "disabled"));
      }

      function disableAnswers(disabled) {
        dom.answers.forEach((a) => a.classList.toggle("disabled", disabled));
      }

      function renderQuestion(q) {
        dom.questionText.textContent = `Question ${state.questionNumber} ‚Äî ${q.text}`;
        dom.answers.forEach((el, i) => {
          el.textContent = q.choices[i] ?? `R√©ponse ${i + 1}`;
        });
      }

      // ---------- TIMER QUESTION (buzz ouvert) ----------
      function stopTimer() {
        if (state.timerId) clearInterval(state.timerId);
        state.timerId = null;
      }

      function startTimer() {
        stopTimer();
        state.remaining = TEMPS_LIMITE;
        setBuzzerText(state.remaining);

        state.timerId = setInterval(() => {
          state.remaining -= 1;
          setBuzzerText(state.remaining);
          if (state.remaining <= 0) {
            stopTimer();
            onTimeElapsed();
          }
        }, 1000);
      }

      // ---------- TIMER fen√™tre r√©ponse apr√®s buzz humain ----------
      function stopAnswerWindow() {
        if (state.answerWindowId) clearInterval(state.answerWindowId);
        state.answerWindowId = null;
      }

      function startAnswerWindow() {
        stopAnswerWindow();
        state.answerWindowRemaining = TEMPS_REPONSE_APRES_BUZZ;

        setHint(`Tu as buzz√©. Tu as ${state.answerWindowRemaining}s pour cliquer une r√©ponse.`);

        state.answerWindowId = setInterval(() => {
          if (!state.awaitingHumanAnswer) {
            stopAnswerWindow();
            return;
          }

          state.answerWindowRemaining -= 1;

          if (state.answerWindowRemaining <= 0) {
            stopAnswerWindow();
            state.awaitingHumanAnswer = false;
            disableAnswers(true);
            setHint("Temps d√©pass√© apr√®s le buzz. Question suivante.");
            nextQuestion();
            return;
          }

          setHint(`Tu as buzz√©. Tu as ${state.answerWindowRemaining}s pour cliquer une r√©ponse.`);
        }, 1000);
      }

      // ---------- TIMER GLOBAL √âPREUVE (NE SE RESET PAS) ----------
      function stopEpreuveTimer() {
        if (state.epreuveTimerId) clearInterval(state.epreuveTimerId);
        state.epreuveTimerId = null;
      }

      function goNextEpreuve() {
        stopTimer();
        stopAnswerWindow();
        closeBuzz();
        stopEpreuveTimer();
        window.location.href = NEXT_PAGE_URL;
      }

      function startEpreuveTimerOnce() {
        if (state.epreuveTimerId) return; // d√©j√† lanc√©
        state.epreuveRemaining = EPREUVE_DURATION;

        state.epreuveTimerId = setInterval(() => {
          state.epreuveRemaining -= 1;

          // IMPORTANT : on ne reset jamais, on ne touche √† rien ailleurs
          if (state.epreuveRemaining <= 0) {
            setHint("Temps total de l‚Äô√©preuve termin√©.");
            goNextEpreuve();
          }
        }, 1000);
      }

      // ---------- UTILS ----------
      function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function clearBotSchedules() {
        state.botTimeouts.forEach(clearTimeout);
        state.botTimeouts = [];
      }

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      // ---------- JSON LOADER ----------
      function normalizeQuestions(raw) {
        if (!Array.isArray(raw)) throw new Error("Le JSON doit √™tre un tableau de questions.");

        return raw.map((item, idx) => {
          const id = item?.id ?? idx;
          const text = String(item?.question ?? "").trim();
          const good = String(item?.Good ?? "").trim();
          const answers = Array.isArray(item?.answers) ? item.answers.map(a => String(a).trim()) : [];

          if (!text) throw new Error(`Question invalide (id=${id}): champ "question" manquant.`);
          if (answers.length !== 4) throw new Error(`Question invalide (id=${id}): "answers" doit contenir 4 r√©ponses.`);
          if (!good) throw new Error(`Question invalide (id=${id}): champ "Good" manquant.`);

          const correctIndex = answers.findIndex(a => a === good);
          if (correctIndex === -1) {
            throw new Error(`Question invalide (id=${id}): "Good" doit correspondre EXACTEMENT √† une valeur de "answers".`);
          }

          return { id, text, choices: answers, correctIndex };
        });
      }

      async function loadQuestions() {
        setHint("Chargement des questions‚Ä¶");
        setBuzzerText("‚Ä¶");
        setBuzzerState("idle");
        disableAnswers(true);

        try {
          const res = await fetch(QUESTIONS_URL, { cache: "no-store" });
          if (!res.ok) throw new Error(`HTTP ${res.status} sur ${QUESTIONS_URL}`);

          const raw = await res.json();
          state.questions = shuffle(normalizeQuestions(raw));

          state.scores = { 1: 0, 2: 0, 3: 0, 4: 0 };
          state.questionIndex = 0;
          state.questionNumber = 1;
          state.gagnant_trouve = false;

          renderScores();
          setHint("Questions charg√©es. Clique sur le buzzer (ou espace) pour buzzer.");
          runQuestion();
        } catch (err) {
          console.error(err);
          setBuzzerText("ERR");
          setBuzzerState("timeup");
          setHint(`Erreur chargement JSON: ${err.message}`);
        }
      }

      // ---------- GAME FLOW ----------
      function openBuzz() {
        state.buzzOpen = true;
        state.respondingPlayer = null;
        state.awaitingHumanAnswer = false;
        stopAnswerWindow();

        setBuzzerState("idle");
        resetAnswersUI();
        disableAnswers(true);
        setActivePlayer(0);

        setHint(`Buzz ouvert (${TEMPS_LIMITE}s). Clique sur le buzzer (ou espace) pour r√©pondre.`);
        scheduleBotsBuzz();
        startTimer();
      }

      function closeBuzz() {
        state.buzzOpen = false;
        clearBotSchedules();
      }

      function onTimeElapsed() {
        if (state.respondingPlayer === null) {
          setBuzzerState("timeup");
          setHint(`Temps √©coul√© (${TEMPS_LIMITE}s). Question suivante.`);
          nextQuestion();
          return;
        }
        setHint("Temps √©coul√©. Question suivante.");
        nextQuestion();
      }

      function scheduleBotsBuzz() {
        clearBotSchedules();

        for (const bot of BOTS) {
          const cfg = BOT_CONFIG[bot];
          if (!cfg) continue;
          if (Math.random() > cfg.buzzChance) continue;

          const delay = randInt(cfg.buzzDelayMin, cfg.buzzDelayMax);
          const t = setTimeout(() => {
            if (state.buzzOpen && state.respondingPlayer === null) onBuzz(bot);
          }, delay);

          state.botTimeouts.push(t);
        }
      }

      function onBuzz(player) {
        if (!state.buzzOpen) return;
        if (state.respondingPlayer !== null) return;

        state.respondingPlayer = player;
        closeBuzz();
        stopTimer();

        flashBuzzer();
        setBuzzerState("buzzed");
        setActivePlayer(player);

        if (player === HUMAN) {
          state.awaitingHumanAnswer = true;
          disableAnswers(false);
          startAnswerWindow();
        } else {
          disableAnswers(true);
          setHint(`${dom.name[player]?.textContent || `Joueur ${player}`} r√©pond‚Ä¶`);
          botAnswer(player);
        }
      }

      function revealAnswerUI(chosenIndex) {
        dom.answers.forEach((el, i) => {
          if (i === state.correctIndex) el.classList.add("correct");
          else if (i === chosenIndex) el.classList.add("wrong");
          el.classList.add("disabled");
        });
      }

      function awardPoint(player) {
        state.scores[player] += 1;
        renderScores();

        const pName = dom.name[player]?.textContent || `Joueur ${player}`;

        if (state.scores[player] >= POINTS_VICTOIRE) {
          state.gagnant_trouve = true;
          setHint(`üèÜ ${pName} gagne la Manche 1 avec ${POINTS_VICTOIRE} points.`);
          endRound();
        } else {
          setHint(`‚úì Bonne r√©ponse (${pName}) ‚Äî ${state.scores[player]} pts. Question suivante.`);
          nextQuestion();
        }
      }

      function handleWrong(player) {
        const pName = dom.name[player]?.textContent || `Joueur ${player}`;
        setHint(`‚úó Mauvaise r√©ponse (${pName}). Question suivante.`);
        nextQuestion();
      }

      function botAnswer(botPlayer) {
        const cfg = BOT_CONFIG[botPlayer] || { accuracy: 0.5 };
        const willBeCorrect = Math.random() < cfg.accuracy;

        let chosenIndex;
        if (willBeCorrect) chosenIndex = state.correctIndex;
        else {
          const pool = [0, 1, 2, 3].filter((i) => i !== state.correctIndex);
          chosenIndex = pool[randInt(0, pool.length - 1)];
        }

        const thinkDelay = randInt(600, 1400);
        setTimeout(() => {
          revealAnswerUI(chosenIndex);

          const ok = chosenIndex === state.correctIndex;
          setTimeout(() => {
            if (ok) awardPoint(botPlayer);
            else handleWrong(botPlayer);
          }, 650);
        }, thinkDelay);
      }

      function onHumanAnswerClick(index) {
        if (!state.awaitingHumanAnswer) return;

        state.awaitingHumanAnswer = false;
        stopAnswerWindow();
        disableAnswers(true);

        revealAnswerUI(index);

        const ok = index === state.correctIndex;
        setTimeout(() => {
          if (ok) awardPoint(HUMAN);
          else handleWrong(HUMAN);
        }, 650);
      }

      function runQuestion() {
        if (state.gagnant_trouve) return;
        if (!state.questions.length) return;

        const q = state.questions[state.questionIndex];
        state.correctIndex = q.correctIndex;

        renderQuestion(q);
        openBuzz();
      }

      function nextQuestion() {
        if (state.gagnant_trouve) return;

        stopTimer();
        stopAnswerWindow();
        closeBuzz();
        disableAnswers(true);

        state.questionNumber += 1;
        state.questionIndex += 1;
        if (state.questionIndex >= state.questions.length) state.questionIndex = 0;

        setTimeout(runQuestion, 450);
      }

      function endRound() {
        stopTimer();
        stopAnswerWindow();
        closeBuzz();
        disableAnswers(true);

        const classement = [1, 2, 3, 4]
          .map((p) => ({ player: p, score: state.scores[p] }))
          .sort((a, b) => b.score - a.score);

        const top3 = classement.slice(0, 3);
        const last = classement[3];

        setHint(
          `FIN ‚Äî Scores: ${dom.name[1].textContent}=${state.scores[1]} | ` +
          `${dom.name[2].textContent}=${state.scores[2]} | ` +
          `${dom.name[3].textContent}=${state.scores[3]} | ` +
          `${dom.name[4].textContent}=${state.scores[4]} ‚Äî ` +
          `Qualifi√©s: ${dom.name[top3[0].player].textContent}, ${dom.name[top3[1].player].textContent}, ${dom.name[top3[2].player].textContent} ‚Äî ` +
          `√âlimin√©: ${dom.name[last.player].textContent}`
        );

        setTimeout(goNextEpreuve, 1500);
      }

      // ---------- EVENTS ----------
      function bindEvents() {
        dom.buzzer.addEventListener("click", () => onBuzz(HUMAN));

        window.addEventListener("keydown", (e) => {
          if (e.code === "Space") {
            e.preventDefault();
            onBuzz(HUMAN);
          }
        });

        dom.answers.forEach((el, i) => el.addEventListener("click", () => onHumanAnswerClick(i)));
      }

      // ---------- START ----------
      function startGame() {
        buildStars();
        applyProfiles();
        bindEvents();
        renderScores();
        setBuzzerText("‚Ä¶");
        setHint("D√©but de l‚Äô√©preuve 1.");

        // IMPORTANT : chrono global d‚Äô√©preuve, une seule fois
        startEpreuveTimerOnce();

        loadQuestions();
      }

      // go
      startGame();
    })();
  </script>
</body>
</html>
